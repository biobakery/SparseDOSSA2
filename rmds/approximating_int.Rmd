---
title: "Approximating the integration"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "/n/janson_lab/lab/sma/sparsedossa_update/")
knitr::opts_chunk$set(echo=FALSE, fig.width=15, cache=TRUE)
library(magrittr)
library(ggplot2)
```

* Evaluating $f_{\log A_s, X}$ requires the integration
$\int_{- \inf}^{F^{-1}_{G_1}(\pi_{01})} f_G(g_1, g_2(\log a_2) | \theta) d g_1$

    * Previous evaluations suggests that $\int_{- \inf}^{F^{-1}_{G_1}(\pi_{01})} f_G(g_1, g_2(\log a_2) | \theta) d g_1 \approx f_{G_2}(g_2(\log a_2) | \theta) \times C(x, \theta)$
    
    * If this holds, then likelihood for $(\log a_s, x)$ simplifies:
        
        * $f_{\log A_s, X}(\log a_s, x | \theta) \approx h(\log a_s, x| \theta) \times C(x, \theta)$
        
    * Within an EM algorithm:
    
        * E step: $E [T(\log A_s) | X] = C(x, \theta) \times \int T(\log A_s) h(\log a_s, x| \theta) d \log a_s$
        
        * M step: maximize $f_{\log A_s, X}(E [T(\log A_s) | X], \theta)$
        
## Solution 1: approximate $h$ and $C$

* Note that 
\begin{aligned}
\int_{- \inf}^{F^{-1}_{G_1}(\pi_{01})} f_G(g_1, g_2(\log a_2) | \theta) d g_1 &=
Pr(g_1 < g^* | \theta) \times f(g_2 | g_1 < g^*, \theta)
\end{aligned}

* $Pr(g_1 < g^* | \theta)$ is $C$. This has ready implementation.

* Accurate evaluation of $f(g_2 | g_1 < g^*, \theta)$ ($h$) requires integrating over 
  $f(g_2 | g_1, \theta) \times f(g_1 | g_1 < g^*, \theta)$. However can 
  approximate with a multivariate normal, matching the first two moments.
  
    * $E g_2 | g_1 < g^* = E (E g_2 | g_1) | g_1 < g^* = E A g_1  + b | g_1 < g^*$
    
    * $E Cov(g_2 | g_1) | g_1 < g^* = Cov(g_2 | g_1) + A Cov(g_1 | g_1 < g^*) A^\prime$
    
    * The first two moments simplify to moments of a truncated multivariate normal
      distribution, which 
      [has been studied](https://www.jstor.org/stable/2983860?seq=1) and 
      [has ready R implementations](https://cran.r-project.org/web/packages/tmvtnorm/index.html).
      
    * However, evaluating first moment requires calculating $p$ MVN integrations,
      and evaluating second moment requires $p^2$ integrations, which becomes
      prohibitive.
      
    * For now, can match just first moment, and replace second moment with either
      $Cov(g_2 | g_1)$ or $Cov(g_2 | g_1) + A Cov(g_1) A^\prime = Cov(g_2)$
      
    * Previous heuristic is essentially claiming $E (E g_2 | g_1) | g_1 < g^* = E g_2 | g^{**}$,
      $E Cov(g_2 | g_1) | g_1 < g^* = Cov(g_2 | g_1^{**}) = Cov(g_2 | g_1)$
      
    * Examing the performance of these three approximations:
    
```{r solution1 evaluation for different loga}
smar::sourceDir("SparseDOSSA2/R/")
dir_output <- "results/approximating_int/"
dir.create(dir_output, recursive = TRUE, showWarnings = TRUE)
load("results/Simulation_smaller/tb_job.RData")
i_tb_job <- tb_job %>% 
  dplyr::filter(dataset == "stool") %>% 
  dplyr::slice(1)
params_subset <- sapply(
  i_tb_job$params[[1]]$mu,
  function(i_mu) {
    i_mu %in% i_tb_job$params_sim[[1]]$mu
  }
)

params <- i_tb_job$params_sim[[1]]
x_samples <- i_tb_job$x_samples[[1]][1:5, ]
a_samples <- i_tb_job$a_samples[[1]][1:5, ]

log_asums <- seq(-5, 5, by = 0.5)
# compare dloga, fixing parameters
d1s <- sapply(1:nrow(x_samples),
              function(i_sample) {
                sapply(log_asums, function(i_logasum)
                  dloga_true(a = a(x = x_samples[i_sample, ],
                                   asum = exp(i_logasum)),
                             pi0 = params$pi0, 
                             mu = params$mu,
                             sigma = params$sigma,
                             Sigma = params$Sigma,
                             Omega = params$Omega)) 
              })
# l_m_cond <- future.apply::future_lapply(
#   1:nrow(x_samples),
#   function(i_sample) {
#     mloga(a = x_samples[i_sample, ],
#           pi0 = params$pi0,
#           mu = params$mu,
#           sigma = params$sigma,
#           Sigma = params$Sigma)
#   }
# )
# save(l_m_cond,
#      file = paste0(dir_output,
#                    "l_m_cond_varyingLogA.RData"))
load(paste0(dir_output, 
            "l_m_cond_varyingLogA.RData"))
d2s_forInt <- future.apply::future_sapply(
  1:nrow(x_samples),
  function(i_sample) {
    m_cond <- l_m_cond[[i_sample]]
    sapply(
      log_asums, 
      function(i_logasum)
        dloga_forInt(a = a(x = x_samples[i_sample, ],
                           asum = exp(i_logasum)),
                     pi0 = params$pi0, 
                     mu = params$mu,
                     sigma = params$sigma,
                     Sigma = params$Sigma,
                     Omega = params$Omega,
                     mean_cond = m_cond$mean_cond,
                     mean_cond_choice = "half"))
  })
d3s_forInt <- future.apply::future_sapply(
  1:nrow(x_samples),
  function(i_sample) {
    m_cond <- l_m_cond[[i_sample]]
    sapply(
      log_asums, 
      function(i_logasum)
        dloga_forInt(a = a(x = x_samples[i_sample, ],
                           asum = exp(i_logasum)),
                     pi0 = params$pi0, 
                     mu = params$mu,
                     sigma = params$sigma,
                     Sigma = params$Sigma,
                     Omega = params$Omega,
                     mean_cond = m_cond$mean_cond,
                     mean_cond_choice = "int"))
  })
d4s_forInt <- future.apply::future_sapply(
  1:nrow(x_samples),
  function(i_sample) {
    m_cond <- l_m_cond[[i_sample]]
    sapply(
      log_asums, 
      function(i_logasum)
        dloga_forInt(a = a(x = x_samples[i_sample, ],
                           asum = exp(i_logasum)),
                     pi0 = params$pi0, 
                     mu = params$mu,
                     sigma = params$sigma,
                     Sigma = params$Sigma,
                     Omega = params$Omega,
                     mean_cond = m_cond$mean_cond,
                     mean_cond_choice = "int",
                     Sigma_cond_choice = "full"))
  })
p2s <- sapply(1:nrow(x_samples),
              function(i_sample)
                ploga(a = x_samples[i_sample, ],
                      pi0 = params$pi0, 
                      mu = params$mu,
                      sigma = params$sigma,
                      Sigma = params$Sigma))
d2s <- t(t(d2s_forInt) + p2s)
d3s <- t(t(d3s_forInt) + p2s)
d4s <- t(t(d4s_forInt) + p2s)

colnames(d1s) <- 
  colnames(d2s) <- 
  colnames(d3s) <- 
  colnames(d4s) <- 
  paste0("Sample", 1:5)
rbind(data.frame(log_asum = log_asums,
                 d1s,
                 method = "Original"),
      data.frame(log_asum = log_asums,
                 d2s,
                 method = "Heuristic"),
      data.frame(log_asum = log_asums,
                 d3s,
                 method = "Cond_Cov"),
      data.frame(log_asum = log_asums,
                 d4s,
                 method = "Marg_Cov")
      ) %>% 
  tidyr::pivot_longer(cols = Sample1:Sample5,
                      names_to = "Sample",
                      values_to = "logLik") %>% 
  ggplot(aes(x = log_asum,
             y = logLik,
             color = method)) +
  geom_point() +
  geom_line() +
  facet_wrap(~Sample, scales = "free_y", nrow = 1)

rbind(data.frame(log_asum = log_asums,
                 d1s,
                 method = "Original"),
      data.frame(log_asum = log_asums,
                 d2s,
                 method = "Heuristic"),
      data.frame(log_asum = log_asums,
                 d3s,
                 method = "Cond_Cov"),
      data.frame(log_asum = log_asums,
                 d4s,
                 method = "Marg_Cov")
      ) %>% 
  tidyr::pivot_longer(cols = Sample1:Sample5,
                      names_to = "Sample",
                      values_to = "logLik") %>% 
  ggplot(aes(x = log_asum,
             y = logLik,
             color = method)) +
  geom_point() +
  geom_line() +
  facet_wrap(~Sample, scales = "free_y", nrow = 1)
```

```{r solution1 evaluation for different param}
load("results/Stool_vaginal/tb_job.RData")
tb_params <- tb_job %>% 
  dplyr::filter(penalize_method == "huge",
                dataset == "stool",
                lambdas > 1e-2)
l_params <- tb_params$i_job %>% 
  purrr::map(~ {
    load(paste0("results/Stool_vaginal/fit_", .x, ".RData"))
    i_params <- fit_EM$l_fits_full[[1]]$fit
    i_params$Sigma <- i_params$Sigma[params_subset, 
                                     params_subset]
    i_params$Omega <- solve(i_params$Sigma)
    i_params
  })

d1s <- sapply(1:nrow(a_samples),
              function(i_sample) {
                sapply(l_params, function(i_params)
                  dloga_true(a = a_samples[i_sample, ],
                             pi0 = params$pi0, 
                             mu = params$mu,
                             sigma = params$sigma,
                             Sigma = i_params$Sigma,
                             Omega = i_params$Omega)) 
              })
# ll_m_cond <- lapply(
#   1:nrow(a_samples),
#   function(i_sample) {
#     future.apply::future_lapply(
#       l_params,
#       function(i_params) {
#         mloga(
#           a = a_samples[i_sample, ],
#           pi0 = params$pi0, 
#           mu = params$mu,
#           sigma = params$sigma,
#           Sigma = i_params$Sigma
#         )
#       })
#   })
# save(ll_m_cond,
#      file = paste0(dir_output,
#                    "ll_m_cond_varyingParam.RData"))
load(paste0(dir_output,
            "ll_m_cond_varyingParam.RData"))
d2s_forInt <- sapply(
  1:nrow(x_samples),
  function(i_sample) {
    sapply(
      seq_along(l_params), 
      function(i_param) {
        m_cond <- ll_m_cond[[i_sample]][[i_param]]
        i_params <- l_params[[i_param]]
        dloga_forInt(a = a_samples[i_sample, ],
                     pi0 = params$pi0, 
                     mu = params$mu,
                     sigma = params$sigma,
                     Sigma = i_params$Sigma,
                     Omega = i_params$Omega,
                     mean_cond = m_cond$mean_cond,
                     mean_cond_choice = "half")
      })
  })
d3s_forInt <- sapply(
  1:nrow(x_samples),
  function(i_sample) {
    sapply(
      seq_along(l_params), 
      function(i_param) {
        m_cond <- ll_m_cond[[i_sample]][[i_param]]
        i_params <- l_params[[i_param]]
        dloga_forInt(a = a_samples[i_sample, ],
                     pi0 = params$pi0, 
                     mu = params$mu,
                     sigma = params$sigma,
                     Sigma = i_params$Sigma,
                     Omega = i_params$Omega,
                     mean_cond = m_cond$mean_cond,
                     mean_cond_choice = "int")
      })
  })
d4s_forInt <- sapply(
  1:nrow(x_samples),
  function(i_sample) {
    sapply(
      seq_along(l_params), 
      function(i_param) {
        m_cond <- ll_m_cond[[i_sample]][[i_param]]
        i_params <- l_params[[i_param]]
        dloga_forInt(a = a_samples[i_sample, ],
                     pi0 = params$pi0, 
                     mu = params$mu,
                     sigma = params$sigma,
                     Sigma = i_params$Sigma,
                     Omega = i_params$Omega,
                     mean_cond = m_cond$mean_cond,
                     mean_cond_choice = "int",
                     Sigma_cond_choice = "full")
      })
  })
p2s <- sapply(1:nrow(x_samples),
              function(i_sample) {
                sapply(l_params, function(i_params)
                  ploga(a = a_samples[i_sample, ],
                        pi0 = params$pi0, 
                        mu = params$mu,
                        sigma = params$sigma,
                        Sigma = i_params$Sigma)) 
              })
d2s <- d2s_forInt + p2s
d3s <- d3s_forInt + p2s
d4s <- d4s_forInt + p2s
colnames(d1s) <- 
  colnames(d2s) <- 
  colnames(d3s) <- 
  colnames(d4s) <- 
  paste0("Sample", 1:5)

rbind(data.frame(lambdas = tb_params$lambdas,
                 d1s,
                 method = "Original"),
      data.frame(lambdas = tb_params$lambdas,
                 d2s,
                 method = "Heuristic"),
      data.frame(lambdas = tb_params$lambdas,
                 d3s,
                 method = "Cond_Cov"),
      data.frame(lambdas = tb_params$lambdas,
                 d4s,
                 method = "Marg_Cov")) %>% 
  tidyr::pivot_longer(cols = Sample1:Sample5,
                      names_to = "Sample",
                      values_to = "logLik") %>% 
  ggplot(aes(x = log10(lambdas),
             y = logLik,
             color = method)) +
  geom_point() +
  geom_line() +
  facet_wrap(~Sample, scales = "free_y", nrow = 1)
```

We can also test this out in a simple case. Set $p = 4$, $A = (0, 0, 0.5, 0.5)$,
evaluate likelihood with $\rho = $ `seq(0.05, 0.5, by = 0.5)`:

```{r unit test for this approach, fig.width=5}
pi0 <- c(0.5, 0.5, 0.5, 0.5)
mu <- c(0, 0, 0, 0)
sigma <- c(1, 1, 1, 1)
Sigma <- matrix(0.3, nrow = 4, ncol = 4)
l_params_unitTest <- seq(0, 0.5, by = 0.05) %>% 
  purrr::map(function(rho) {
    Sigma <- matrix(rho, nrow = 4, ncol = 4)
    diag(Sigma) <- 1
    Omega <- solve(Sigma)
    list(Sigma = Sigma, Omega = Omega)
  })
x <- c(0, 0, 0.5, 0.5)

l_m_cond <- lapply(
  l_params_unitTest, 
  function(i_params) {
    mloga(a = x, pi0 = pi0, mu = mu, sigma = sigma, Sigma = i_params$Sigma,
          doComputeVariance = TRUE)
  })

# compare dloga, fixing parameters
d1s <- l_params_unitTest %>% 
  purrr::map2_dbl(
    l_m_cond,
    function(i_params, m_cond)
      dloga_true(a = x,
                 pi0 = pi0, 
                 mu = mu,
                 sigma = sigma,
                 Sigma = i_params$Sigma,
                 Omega = i_params$Omega))

d2s_forInt <- l_params_unitTest %>% 
  purrr::map2_dbl(
    l_m_cond,
    function(i_params, m_cond)
      dloga_forInt(a = x,
                   pi0 = pi0, 
                   mu = mu,
                   sigma = sigma,
                   Sigma = i_params$Sigma,
                   Omega = i_params$Omega,
                   mean_cond = m_cond$mean_cond,
                   Sigma_cond = m_cond$Sigma_cond,
                   mean_cond_choice = "half",
                   Sigma_cond_choice = "cond"))

d3s_forInt <- l_params_unitTest %>% 
  purrr::map2_dbl(
    l_m_cond,
    function(i_params, m_cond)
      dloga_forInt(a = x,
                   pi0 = pi0, 
                   mu = mu,
                   sigma = sigma,
                   Sigma = i_params$Sigma,
                   Omega = i_params$Omega,
                   mean_cond = m_cond$mean_cond,
                   Sigma_cond = m_cond$Sigma_cond,
                   mean_cond_choice = "int",
                   Sigma_cond_choice = "cond"))

d4s_forInt <- l_params_unitTest %>% 
  purrr::map2_dbl(
    l_m_cond,
    function(i_params, m_cond)
      dloga_forInt(a = x,
                   pi0 = pi0, 
                   mu = mu,
                   sigma = sigma,
                   Sigma = i_params$Sigma,
                   Omega = i_params$Omega,
                   mean_cond = m_cond$mean_cond,
                   Sigma_cond = m_cond$Sigma_cond,
                   mean_cond_choice = "int",
                   Sigma_cond_choice = "full"))


d5s_forInt <- l_params_unitTest %>% 
  purrr::map2_dbl(
    l_m_cond,
    function(i_params, m_cond)
      dloga_forInt(a = x,
                   pi0 = pi0, 
                   mu = mu,
                   sigma = sigma,
                   Sigma = i_params$Sigma,
                   Omega = i_params$Omega,
                   mean_cond = m_cond$mean_cond,
                   Sigma_cond = m_cond$Sigma_cond,
                   mean_cond_choice = "int",
                   Sigma_cond_choice = "int"))
p2s <- l_params_unitTest %>% 
  purrr::map_dbl(
    function(i_params)
      ploga(a = x,
            pi0 = pi0, 
            mu = mu,
            sigma = sigma,
            Sigma = i_params$Sigma)
  )

d2s <- d2s_forInt + p2s
d3s <- d3s_forInt + p2s
d4s <- d4s_forInt + p2s
d5s <- d5s_forInt + p2s

rbind(data.frame(rho = seq(0, 0.5, by = 0.05),
                 logLik = d1s,
                 method = "Original"),
      data.frame(rho = seq(0, 0.5, by = 0.05),
                 logLik = d2s,
                 method = "Heuristic"),
      data.frame(rho = seq(0, 0.5, by = 0.05),
                 logLik = d3s,
                 method = "Cond_cov"),
      data.frame(rho = seq(0, 0.5, by = 0.05),
                 logLik = d4s,
                 method = "Marg_cov"),
      data.frame(rho = seq(0, 0.5, by = 0.05),
                 logLik = d5s,
                 method = "Both_moments")
      ) %>% 
  ggplot(aes(x = rho,
             y = logLik,
             color = method)) +
  geom_point() +
  geom_line()
```

## Solution 2: $f_{\log A}$ is quadratic in $\log a_s$?

Noticing the quadratic shape of $\log f_{A_1, \log A_2}(\log a_2)$ on $\log a_s$,
interpolate this function from a couple of points?

```{r solution2 evaluation for different loga}
# true values
d1s <- sapply(1:nrow(x_samples),
              function(i_sample) {
                sapply(log_asums, function(i_logasum)
                  dloga_true(a = a(x = x_samples[i_sample, ],
                                   asum = exp(i_logasum)),
                             pi0 = params$pi0, 
                             mu = params$mu,
                             sigma = params$sigma,
                             Sigma = params$Sigma,
                             Omega = params$Omega)) 
              })
# interpolte a quadratic curve from true values
d2s <- sapply(1:nrow(x_samples),
              function(i_sample) {
                coef_lm <- lm(d1s[, i_sample] ~ log_asums + I(log_asums^2))$coef
                fit_fun <- function(x) coef_lm[1] + coef_lm[2] * x + coef_lm[3] * x^2
                fit_fun(log_asums)
              })
colnames(d1s) <- 
  colnames(d2s) <- 
  paste0("Sample", 1:5)

rbind(data.frame(log_asum = log_asums,
                 d1s,
                 method = "Original"),
      data.frame(log_asum = log_asums,
                 d2s,
                 method = "Interpolated")) %>% 
  tidyr::pivot_longer(cols = Sample1:Sample5,
                      names_to = "Sample",
                      values_to = "logLik") %>% 
  ggplot(aes(x = log_asum,
             y = logLik,
             color = method)) +
  geom_point() +
  geom_line() +
  facet_wrap(~Sample, scales = "free_y", nrow = 1)
```

```{r solution2 evaluation for different param}
# true values
d1s <- sapply(1:nrow(a_samples),
              function(i_sample) {
                sapply(l_params, function(i_params)
                  dloga_true(a = a_samples[i_sample, ],
                             pi0 = params$pi0, 
                             mu = params$mu,
                             sigma = params$sigma,
                             Sigma = i_params$Sigma,
                             Omega = i_params$Omega)) 
              })
# ll_coef <- future.apply::future_lapply(
#   1:nrow(x_samples),
#   function(i_sample) {
#     lapply(
#       l_params,
#       function(i_params) {
#         d_true <- sapply(
#           log_asums,
#           function(i_logasum)
#             dloga_true(a = a(x = x_samples[i_sample, ],
#                              asum = exp(i_logasum)),
#                        pi0 = params$pi0,
#                        mu = params$mu,
#                        sigma = params$sigma,
#                        Sigma = i_params$Sigma,
#                        Omega = i_params$Omega))
#         lm(d_true ~ log_asums + I(log_asums^2))$coef
#       })  
#   })
# save(ll_coef,
#      file = paste0(dir_output,
#                    "ll_coef.RData"))
load(paste0(dir_output,
            "ll_coef.RData"))
d2s <- sapply(
  1:nrow(x_samples),
  function(i_sample) {
    i_logasum <- log(sum(a_samples[i_sample, ]))
    sapply(
      seq_along(l_params), 
      function(i_param) {
        coef_lm <- ll_coef[[i_sample]][[i_param]]
        coef_lm[1] + coef_lm[2] * i_logasum + coef_lm[3] * i_logasum^2
      })
  })
colnames(d1s) <- 
  colnames(d2s) <- 
  paste0("Sample", 1:5)

rbind(data.frame(lambdas = tb_params$lambdas,
                 d1s,
                 method = "Original"),
      data.frame(lambdas = tb_params$lambdas,
                 d2s,
                 method = "Interpolated")) %>% 
  tidyr::pivot_longer(cols = Sample1:Sample5,
                      names_to = "Sample",
                      values_to = "logLik") %>% 
  ggplot(aes(x = log10(lambdas),
             y = logLik,
             color = method)) +
  geom_point() +
  geom_line() +
  facet_wrap(~Sample, scales = "free_y", nrow = 1)
```