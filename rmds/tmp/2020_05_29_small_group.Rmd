---
title: "2020_05_29 small group"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "/n/janson_lab/lab/sma/sparsedossa_update/")
knitr::opts_chunk$set(echo = FALSE)
library(magrittr)
library(ggplot2)
```

* SparseDOSSA
    * Unitested numerical integration (E-step) and
      correlation matrix calculation (M-step)
        * For numerical integration: checked that density integrates to one 
        * For correlation calculation: checked inverting function maps back to 
          original value
    * Ran results on stool samples ($n = 200, p = 250$)
        * CV likelihoods make sense
        * Still has errors (algorithm converging, likelihood not increasing)
        * Is still a procedure??
    
```{r}
load("results/attic/Stool_vaginal/2020_05_26/tb_job.RData")
tb_job <- tb_job %>% 
  dplyr::filter(dataset == "stool")
tb_job <- tb_job %>% 
  dplyr::group_by(i_job) %>% 
  dplyr::mutate(fit_EM = {
    load(paste0("results/attic/Stool_vaginal/2020_05_26/fit_", i_job, ".RData"))
    fit_EM %>% list()
  })
tb_job <- tb_job %>% 
  dplyr::group_by(i_job) %>% 
  dplyr::mutate(logLik = fit_EM[[1]]$l_fits_full[[1]]$fit$logLik,
                logLik_CV = fit_EM[[1]]$logLik_CV %>% setdiff(NaN) %>% mean(),
                sd_CV = fit_EM[[1]]$logLik_CV %>% setdiff(NaN) %>% {sd(.) / sqrt(length(.))}) %>% 
  dplyr::ungroup()

tb_job %>% 
  ggplot(aes(x = log10(lambdas),
             y = logLik_CV)) +
  geom_point() +
  geom_errorbar(aes(ymax = logLik_CV + sd_CV, ymin = logLik_CV - sd_CV)) +
  geom_point(aes(x = log10(lambdas),
                 y = logLik),
             color = "red")
```

* Distilled CRT
    * Better test statistic
        * Fit $Y \sim \frac{X_{-j}}{\sum X_{-j}}$ to obtain 
          $\hat{Y} = \hat{E} Y|\frac{X_{-j}}{\sum X_{-j}}$
        * Resample $X_j^r$ based on $X_j | \frac{X_{-j}}{\sum X_{-j}}$
        * Use $Y \sim glm(X_j, \hat{Y})$ instead of $Y - \hat{Y} \sim X_j$
    * Correct CRT sampling
        * Empirically checked that M-H for zero-inflated model is valid
        * Unit tests ensured likelihood is correct ($f(x_j, x_{-j}$ and 
          $f(x_j, x_{-j} / \sum x_{-j})$)
        * New proposal distribution for better exploration of sample space

```{r summarize results, echo=FALSE}
dir_output <- "/n/janson_lab/lab/sma/CRT_microbiome/results/dCRT_proof/"
# batchtools::loadRegistry(file.dir = "r_batchtools_reg/dCRT_proof/", writeable = FALSE)
load(file = paste0(dir_output, "tb_job_testing.RData"))

extract_p <- function(result) {
  beta_data <- result$fit_original_data$coef[2]
  beta_CR <- vapply(result$l_fit_random_data,
                    function(i_result)
                      i_result$coef[2],
                    0.0)
  list(p = 1 - mean(abs(beta_data) > abs(beta_CR), na.rm = TRUE),
       beta_data = beta_data,
       beta_CR = beta_CR)
}
# 
# tb_result <- tb_job %>%
#   dplyr::filter(i_job %in% batchtools::findDone()$job.id)
# 
# l_results <- list()
# l_summary <- list()
# for(i_row in seq_len(nrow(tb_result))) {
#   if(i_row %% 20 == 0) print(i_row)
#   load(paste0(dir_output, "fit_", tb_result$i_job[i_row], ".RData"))
#   l_results[[i_row]] <- result_CRT
#   l_summary[[i_row]] <- extract_p(result_CRT)
# }

# tb_result <-  tb_result %>%
#   dplyr::mutate(
#     summary = l_summary
#   ) %>%
#   dplyr::mutate(
#     p = summary %>%
#       purrr::map_dbl("p")
#   )
# save(tb_result, file = paste0(dir_output, "tb_result.RData"))
load(paste0(dir_output, "tb_result.RData"))
```


```{r summarize, echo=FALSE}
features_TP <- tibble::tibble(
  mean = (1 - tb_result$params_x[[1]]$pi0) * exp(tb_result$params_x[[1]]$mu)
) %>%
  dplyr::mutate(feature = seq_len(dplyr::n())) %>%
  dplyr::arrange(-mean) %>%
  {.[c(1, 11), ]$feature}
features_FP <- tibble::tibble(
  mean = (1 - tb_result$params_x[[1]]$pi0) * exp(tb_result$params_x[[1]]$mu)
) %>%
  dplyr::mutate(feature = seq_len(dplyr::n())) %>%
  dplyr::arrange(-mean) %>%
  {.[c(2, 12), ]$feature}

tb_result %>%
  dplyr::mutate(feature = factor(feature_test, levels = c(features_TP, features_FP)),
                n = factor(n, levels = c(50, 100, 200))) %>%
  dplyr::filter(penalize_method == "ridge",
                sampling_method == "sequential") %>% 
  ggplot(aes(x = n, y = p)) +
  geom_point(position = position_jitter(width = 0.25), size = 3) +
  facet_grid(feature ~ signal_strength) + 
  ggtitle("ridge fits")
```