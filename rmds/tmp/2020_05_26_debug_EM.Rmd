---
title: "Debug EM"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "/n/janson_lab/lab/sma/sparsedossa_update/")
knitr::opts_chunk$set(echo=FALSE)
library(magrittr)
library(ggplot2)
```

```{r setup2, include=FALSE}
# Registry
# batchtools::makeRegistry(file.dir = "r_batchtools_reg/tmp/2020_05_26_debug_EM", 
#                          package = "magrittr")
batchtools::loadRegistry(file.dir = "r_batchtools_reg/tmp/2020_05_26_debug_EM", 
                         writeable = TRUE)
batchtools::clearRegistry()

# Grid parameters
ncpus <- 45
partition <- "janson_cascade"
walltime <- 48 * 3600

# Output dir
dir_output <- "/n/janson_lab/lab/sma/sparsedossa_update/results/tmp/2020_05_26_debug_EM/"
dir.create(dir_output, recursive = TRUE, showWarnings = FALSE)
smar::sourceDir("SparseDOSSA2/R/")
```

```{r define EM to be just updating sigmas}
EM_diagnose <- function(data, 
                        lambdas,
                        control = list()) {
  control <- do.call(control_EM, control)
  if(!is.null(control$debug_dir))
    dir.create(control$debug_dir)
  
  # Filtering out features/samples that are all zero
  l_filtering <- filter_data(data)
  data <- data[l_filtering$ind_sample, l_filtering$ind_feature, drop = FALSE]
  
  # Initialize using relative abundances
  fit_marginals <- get_marginals(data)
  
  l_fits <- list()
  for(i_lambda in seq_along(lambdas)) {
    if(control$verbose) message("Fitting for lambda ", i_lambda)
    lambda <- lambdas[i_lambda]
    
    l_fits[[i_lambda]] <- {
      
      # Initialize using relative abundances
      fit_copulasso <- copulasso(
        data = data, 
        marginals = fit_marginals,
        lambda = lambda,
        control = 
          c(control$control_copulasso,
            list(debug_file = 
                   paste0(control$debug_dir,
                          "debug_glasso_lambda_", 
                          i_lambda, ".RData")))) ## FIXME
      params <- list(pi0 = fit_marginals$pi0,
                     mu = fit_marginals$mu,
                     sigma = fit_marginals$sigma,
                     Sigma = fit_copulasso$Sigma,
                     Omega = fit_copulasso$Omega,
                     Corr_star = fit_copulasso$Corr_star,
                     diff = rep(NA_real_, 4),
                     logLik = NA_real_,
                     time = Sys.time())
      
      i_iter <- 0
      converge <- FALSE
      if(fit_copulasso$copulasso_code != 0) {
        warning("Missing values in Omega estimation! (lambda to small?)")
        return(list(lambda = lambda,
                    fit = params,
                    convergence = list(converge = converge,
                                       converge_code = 4,
                                       n_iter = i_iter)))
      }
        
      ll_easums <- list()
      ll_params <- list()
      while(TRUE) {
        i_iter <- i_iter + 1
        if(control$verbose)
          message("EM iteration ", i_iter)
        
        ## E step
        e_asums <- future.apply::future_vapply(
          seq_len(nrow(data)),
          function(i_sample)
            get_es(x = data[i_sample, , drop = TRUE],
                   pi0 = params$pi0, mu = params$mu, sigma = params$sigma, 
                   Omega = params$Omega, Sigma = params$Sigma,
                   control = control$control_numint),
          rep(0.0, 10)
        ) %>% t()
        if(any(is.na(e_asums[, c("ea", "logLik", "eloga", "eloga2")]))) {
          warning("Numeric integration in E step returned NAs!")
          converge_code <- 3
          break
        }
        if(any(e_asums[, "eloga"]^2 > e_asums[, "eloga2"])) {
          warning("Numeric integration in E step gave bad expectation values!")
          converge_code <- 2
          break
        }
        ll_easums[[i_iter]] <- e_asums
        
        ## M step
        a_data <- data * e_asums[, "ea"] ## FIXME
        fit_sigmas <- get_sigmas(x = data, 
                                 eloga = e_asums[, "eloga"], 
                                 eloga2 = e_asums[, "eloga2"], 
                                 mu = fit_marginals$mu)
        fit_marginals$sigma <- fit_sigmas
        
        params_new <- list(pi0 = fit_marginals$pi0,
                           mu = fit_marginals$mu,
                           sigma = fit_sigmas,
                           Sigma = params$Sigma,
                           Omega = params$Omega,
                           Corr_star = params$Corr_star)
        diff_abs <- vapply(
          c("sigma", "Corr_star"), 
          function(i_param)
            get_diff(params_new[[i_param]], params[[i_param]], 
                     denom_c = control$abs_tol, method = "abs"),
          0.0)
        diff_rel <- vapply(
          c("sigma", "Corr_star"), 
          function(i_param)
            get_diff(params_new[[i_param]], params[[i_param]], 
                     denom_c = control$abs_tol, method = "rel"),
          0.0)
        params <- c(params_new,
                    list(diff = c(diff_abs, diff_rel),
                         logLik = mean(e_asums[, "logLik"]),
                         time = Sys.time()))
        ll_params[[i_iter]] <- params
        
        if(!is.null(control$debug_dir)) {
          l_debug <- list(ll_easums = ll_easums, 
                          ll_params = ll_params, 
                          l_filtering = l_filtering)
          save(l_debug,
               file = paste0(control$debug_dir,
                             "debug_lambda_", i_lambda, ".RData"))
        }
        
        if(max(diff_abs) < control$abs_tol & max(diff_rel) < control$rel_tol) {
          converge <- TRUE
          converge_code <- 0
          break
        }
        if(i_iter + 1 > control$maxit) {
          warning("Maximum EM iteration reached!")
          converge_code <- 1
          break
        }
      }
      
      list(lambda = lambda,
                  fit = params,
                  convergence = list(converge = converge,
                                     converge_code = converge_code,
                                     n_iter = i_iter))
    }
  }
  
  l_fits <- future::values(l_fits)
  return(list(l_fits = l_fits,
              l_filtering = l_filtering))
}
```

```{r setup simulation params}
tb_job <- rbind(
  tidyr::expand_grid(
    lambdas = 10^seq(from = -3, to = 0, length.out = 7)
  )
) %>% 
  tidyr::expand_grid(dataset = c("vaginal", "stool")) %>% 
  dplyr::mutate(i_job = seq_len(dplyr::n()))
save(tb_job, file = paste0(dir_output, "tb_job.RData"))
```

```{r load datasets}
load("data/physeqs/HMP1II_vaginal.RData")
load("data/physeqs/HMP1II_stool.RData")

x_samples_vaginal <- physeq_vaginal %>% 
  smar::otu_table2() %>% 
  t()
# first subset to top 100 samples with deepest sequencing depth
x_samples_vaginal <- 
  x_samples_vaginal[x_samples_vaginal %>% 
                      apply(1, sum) %>% 
                      {order(-.)[1:20]}, ]
# remove features with at most one non-zero values
x_samples_vaginal <- 
  x_samples_vaginal[, (x_samples_vaginal > 0) %>% 
                      apply(2, sum) %>% 
                      {. >= 2}]
# finally subset to top 200 features with largest average relative abundance
x_samples_vaginal <- 
  x_samples_vaginal[, x_samples_vaginal %>% 
                      apply(1, TSS) %>% 
                      apply(1, mean) %>% 
                      {order(-.)[1:50]}]
# set to relative abundance
x_samples_vaginal <- 
  x_samples_vaginal %>% 
  apply(1, TSS) %>% 
  t()

x_samples_stool <- physeq_stool %>% 
  smar::otu_table2() %>% 
  t()
# first subset to top 100 samples with deepest sequencing depth
x_samples_stool <- 
  x_samples_stool[x_samples_stool %>% 
                      apply(1, sum) %>% 
                      {order(-.)[1:20]}, ]
# remove features with at most one non-zero values
x_samples_stool <- 
  x_samples_stool[, (x_samples_stool > 0) %>% 
                      apply(2, sum) %>% 
                      {. >= 2}]
# finally subset to top 200 features with largest average relative abundance
x_samples_stool <- 
  x_samples_stool[, x_samples_stool %>% 
                      apply(1, TSS) %>% 
                      apply(1, mean) %>% 
                      {order(-.)[1:50]}]
# set to relative abundance
x_samples_stool <- 
  x_samples_stool %>% 
  apply(1, TSS) %>% 
  t()
```

```{r simulation task}
one_job <- function(i_job) {
  future::plan(list(future::sequential, future::sequential, future::multicore))
  i_tb_job <- tb_job[i_job, ]
  if(i_tb_job$dataset == "vaginal")
    x_samples <- x_samples_vaginal
  if(i_tb_job$dataset == "stool")
    x_samples <- x_samples_stool

  # fit SparseDOSSA
  fit_EM <- EM_diagnose_CV(
    data = x_samples,
    lambdas = i_tb_job$lambdas,
    K = 5,
    control = list(abs_tol = 1e-3,
                   rel_tol = 1,
                   maxit = 100,
                   verbose = TRUE,
                   debug_dir = paste0(dir_output, i_job, "/")))
  
  fit_EM <- EM_diagnose(
    data = x_samples,
    lambdas = i_tb_job$lambdas,
    control = list(abs_tol = 1e-3,
                   rel_tol = 1,
                   maxit = 100,
                   verbose = TRUE,
                   debug_dir = paste0(dir_output, i_job, "/"),
                   control_numint = list(rel_tol = 1e-3,
                                         abs_tol = 0,
                                         max_eval = 50)))
  save(fit_EM, file = paste0(dir_output, "fit_", i_job, ".RData"))
}
```

```{r submit jobs}
time_start <- Sys.time()
tb_ids <- batchtools::batchMap(one_job, 
                               i_job = tb_job$i_job[1:2])
batchtools::batchExport(mget(ls()))
batchtools::submitJobs(resources =  list(ncpus = ncpus, 
                                         partition = partition, 
                                         walltime = walltime))
print(Sys.time() - time_start)
```

```{r debug}
# load(paste0(dir_output, "16/K0/debug_lambda_1.RData"))
# l_fits_full <- list(list(
#   l_fits = list(list(lambda = lambdas[1],
#                      fit = rev(l_debug$ll_params)[[1]],
#                      convergence = TRUE)),
#   l_fitering = l_debug$l_filtering
# ))
# for(k in 1:5) {
#   data_training <- data[CV_folds != k, ]
#   data_testing <- data[CV_folds == k, ]
#   control_tmp <- control
#   control_tmp$debug_dir <- paste0(control$debug_dir, "K", k, "/")
#   
#   load(paste0(dir_output, "16/K", k, "/debug_lambda_1.RData"))
#   result_k <- list(l_fits = list(list(lambda = lambdas[1],
#                                       fit = rev(l_debug$ll_params)[[1]],
#                                       convergence = TRUE)),
#                    l_filtering = l_debug$l_filtering)
#   
#   # Fill in parameters estimates for features not present in training data
#   for(i_lambda in seq_along(lambdas))
#     result_k$l_fits[[i_lambda]]$fit <- fill_estimates_CV(result_k$l_fits[[i_lambda]]$fit,
#                                                          l_fits_full[[i_lambda]]$fit,
#                                                          result_k$l_filtering$ind_feature)
#   
#   # Calculate ll in testing data
#   params <- result_k$l_fits[[1]]$fit
#   for(i_sample in seq_len(nrow(data_testing))) {
#     logLik <- dx(x = data_testing[i_sample, , drop = TRUE],
#                  pi0 = params$pi0, mu = params$mu,
#                  sigma = params$sigma, Omega = params$Omega,
#                  control = control$control_numint,
#                  log.p = TRUE)
#   }
# }
# 
# for(i_sample in 200:nrow(data)) {
#   print(i_sample)
#   print(Sys.time())
#   
#   num <- ea(x = data[i_sample, , drop = TRUE],
#             pi0 = params$pi0, mu = params$mu, 
#             sigma = params$sigma, Omega = params$Omega,
#             control = c(control$control_numint, 
#                         list(only_value = FALSE)))
#   eloga_num <- eloga(x = data[i_sample, , drop = TRUE],
#                      pi0 = params$pi0, mu = params$mu, 
#                      sigma = params$sigma, Omega = params$Omega,
#                      control = c(control$control_numint, 
#                                  list(only_value = FALSE)))
#   eloga2_num <- eloga2(x = data[i_sample, , drop = TRUE],
#                        pi0 = params$pi0, mu = params$mu, 
#                        sigma = params$sigma, Omega = params$Omega,
#                        control = c(control$control_numint, 
#                                    list(only_value = FALSE)))
#   denom <- dx(x = data[i_sample, , drop = TRUE],
#               pi0 = params$pi0, mu = params$mu, 
#               sigma = params$sigma, Omega = params$Omega,
#               control = c(control$control_numint, 
#                           list(only_value = FALSE)))
#   
#   if(any(is.na(c("mean" = num$integral / denom$integral,
#                  "error" = abs(num$error / denom$integral) + 
#                  abs(num$integral / (denom$integral)^2 * 
#                      denom$error),
#                  "logLik" = log(denom$integral),
#                  "eloga" = eloga_num$integral / denom$integral,
#                  "eloga2" = eloga2_num$integral / denom$integral
#   ))))
#     break
# }
# 
# job_ids <- tb_job$i_job %>% 
#   setdiff(batchtools::findDone()$job.id) %>% 
#   setdiff(batchtools::findErrors()$job.id)
# 
# setdiff(job_ids, 24) %>% 
#   purrr::map_dbl(
#     ~ {
#       if("K0" %in% dir(paste0(dir_output, .x, "/"))) {
#         load(paste0(dir_output, .x, "/K0/debug_lambda_1.RData"))
#         length(l_debug$ll_params)
#       }
#       else 0
#     }
#   )
```